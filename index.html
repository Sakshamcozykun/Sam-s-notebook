<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sam's Notebook - Resizable/Deletable Elements & Upload</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Kalam:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            /* Prevent text selection during drag/resize */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .notebook-container {
            width: 100%;
            max-width: 80rem; /* Wider to accommodate two pages */
            height: 85vh;
            max-height: 700px;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1500px;
        }

        .notebook {
            display: flex;
            width: 100%;
            height: 100%;
            background-color: #a7f3d0; /* Light green spine/background */
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border-radius: 0.5rem;
            overflow: hidden;
            position: relative;
            transform-style: preserve-3d;
        }

        .page-display {
            flex: 1;
            height: 100%;
            background-color: white;
            position: relative;
            border: 1px solid #d1d5db;
            overflow: hidden;
            transition: transform 0.6s ease-in-out, opacity 0.6s ease-in-out;
            backface-visibility: hidden;
            transform-origin: left center; /* Default for right page */
        }

        #left-page {
            border-right: 2px solid #6ee7b7;
            border-radius: 0.5rem 0 0 0.5rem;
            transform-origin: right center; /* Left page rotates from its right edge */
        }

        #right-page {
            border-radius: 0 0.5rem 0.5rem 0;
            transform-origin: left center; /* Right page rotates from its left edge */
        }

        /* Animation classes */
        .page-flipping-out-left { transform: rotateY(-15deg); opacity: 0; }
        .page-flipping-in-left { transform: rotateY(15deg); opacity: 0; }
        .page-flipping-out-right { transform: rotateY(15deg); opacity: 0; }
        .page-flipping-in-right { transform: rotateY(-15deg); opacity: 0; }

        .page-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            background-image: linear-gradient(to bottom, transparent 98%, #9ae6b4 98%);
            background-size: 100% 2em; /* Lined paper effect */
            font-family: 'Kalam', cursive;
            padding: 1.5rem;
            overflow: auto; /* Allow scrolling if content overflows */
            /* Allow text selection within contenteditable */
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        #page-data-storage { display: none; }

        /* --- Scrapbook Element Styles --- */
        .scrapbook-element {
            position: absolute;
            cursor: grab;
            border: 1px dashed transparent;
            padding: 5px; /* Base padding */
            min-width: 50px;
            min-height: 30px;
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
            /* Required for resize handles/delete button positioning */
            overflow: visible; /* Allow handles/buttons to show outside */
        }

        .scrapbook-element:hover,
        .scrapbook-element.selected { /* Show border when hovered or selected */
            border-color: #34d399;
            z-index: 1000 !important; /* Bring to front */
        }
        .scrapbook-element.dragging {
            cursor: grabbing;
            opacity: 0.7;
            z-index: 9999 !important;
        }
        .scrapbook-text {
            font-family: 'Kalam', cursive;
            line-height: 1.5;
            outline: none;
            color: #1f2937;
            min-width: 100px;
            min-height: 1.5em;
            /* Allow text selection inside */
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }
        .scrapbook-image {
            /* Ensure container resizes with image */
            width: fit-content;
            height: fit-content;
            padding: 0; /* Remove padding for image wrapper */
            overflow: hidden; /* Clip image within container bounds */
        }
        .scrapbook-image img {
            display: block;
            width: 100%; /* Image fills container */
            height: 100%;
            object-fit: contain;
            /* Prevent image interaction */
            pointer-events: none;
        }

        /* --- Delete Button --- */
        .delete-button {
            position: absolute;
            top: -10px; /* Position slightly outside */
            right: -10px;
            width: 20px;
            height: 20px;
            background-color: #ef4444; /* Red */
            color: white;
            border: 1px solid #b91c1c; /* Darker red border */
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            line-height: 18px; /* Center the 'X' */
            text-align: center;
            cursor: pointer;
            z-index: 1001; /* Above the element */
            display: none; /* Hidden by default */
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .scrapbook-element:hover .delete-button,
        .scrapbook-element.selected .delete-button {
            display: block; /* Show on hover or selection */
        }
        .delete-button:hover {
            background-color: #dc2626; /* Darker red on hover */
        }

        /* --- Resize Handles --- */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #34d399; /* Green */
            border: 1px solid #047857; /* Darker green border */
            border-radius: 2px;
            z-index: 1002; /* Above delete button */
            display: none; /* Hidden by default */
        }
        .scrapbook-image:hover .resize-handle, /* Only show for images */
        .scrapbook-image.selected .resize-handle {
            display: block; /* Show on hover or selection */
        }
        .resize-handle.nw { top: -6px; left: -6px; cursor: nwse-resize; }
        .resize-handle.ne { top: -6px; right: -6px; cursor: nesw-resize; }
        .resize-handle.sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .resize-handle.se { bottom: -6px; right: -6px; cursor: nwse-resize; }

        /* ----------------------------------------- */

        /* Cover Styling */
        .cover-content {
            background-image: linear-gradient(to bottom right, #34d399, #10b981);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: inherit;
            font-family: 'Inter', sans-serif;
        }
        .frog-icon { font-size: 4rem; margin-top: 1rem; }

        /* Button Styling */
        .controls-container { /* Container for the buttons */
            @apply mt-8 flex justify-center items-center space-x-4; /* Added space-x-4 for consistent spacing */
        }

        .control-button { /* Style for Prev/Next buttons */
             @apply px-4 py-2 bg-emerald-500 text-white rounded-lg shadow-lg hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-opacity-75 transition duration-200 ease-in-out disabled:opacity-60 disabled:cursor-not-allowed disabled:shadow-md disabled:bg-emerald-400 flex items-center justify-center;
             font-size: 1rem;
             font-weight: bold;
             min-width: 90px;
             line-height: 1.5;
        }

        #add-image-button { /* Specific style for the icon-only button */
             @apply p-2 bg-emerald-500 text-white rounded-lg shadow-lg hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-opacity-75 transition duration-200 ease-in-out disabled:opacity-60 disabled:cursor-not-allowed disabled:shadow-md disabled:bg-emerald-400 flex items-center justify-center;
             /* Removed min-width, adjusted padding to be square-like */
        }

        #add-image-button svg { /* Style for the icon inside the button */
            width: 1.5em; /* Slightly larger icon */
            height: 1.5em;
             /* Removed margin-right as there's no text */
            flex-shrink: 0;
        }


        /* Helper class for placeholder pages */
        .placeholder-page {
            background-color: #f0fdf4;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #a1a1aa;
            font-style: italic;
            user-select: none; /* Prevent interaction */
            -webkit-user-select: none;
        }

        /* Hide the actual file input */
        #image-upload-input {
            display: none;
        }

    </style>
</head>
<body class="bg-green-50 flex flex-col justify-center items-center min-h-screen p-4 overflow-hidden">

    <div class="notebook-container">
        <div class="notebook">
            <div id="left-page" class="page-display">
                <div class="page-content placeholder-page">(Inside Cover)</div>
            </div>
            <div id="right-page" class="page-display">
                <div class="cover-content" id="cover-content-display">
                    <h1>Sam's Notebook</h1>
                    <div class="frog-icon">🐸</div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="image-upload-input" accept="image/*">

    <div id="page-data-storage">
        <div class="page-content" data-page-number="0">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Inside Cover</h2>
            </div>

        <div class="page-content" data-page-number="1">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 1</h2>
            <div class="scrapbook-element scrapbook-text" style="left: 50px; top: 80px; width: 200px; z-index: 11;" contenteditable="true">My first note!</div>
        </div>
        <div class="page-content" data-page-number="2">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 2</h2>
        </div>

        <div class="page-content" data-page-number="3">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 3</h2>
            <div class="scrapbook-element scrapbook-image" style="left: 80px; top: 120px; width: 150px; height: 100px; z-index: 12;">
                 <img src="https://placehold.co/150x100/e0e0e0/757575?text=Paste+Image" alt="Placeholder Image">
                 </div>
        </div>
         <div class="page-content" data-page-number="4">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 4</h2>
        </div>

         <div class="page-content" data-page-number="5">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 5</h2>
        </div>
         <div class="page-content" data-page-number="6">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 6</h2>
        </div>

        <div class="page-content" data-page-number="7">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Inside Back Cover</h2>
        </div>
    </div>

    <div class="controls-container">
        <button id="prev-page" class="control-button" disabled>&lt; Prev</button>
        <button id="add-image-button" title="Add Image from Device">
             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" />
             </svg>
             </button>
        <button id="next-page" class="control-button">Next &gt;</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Get references to DOM elements
            const notebook = document.querySelector('.notebook');
            const leftPageDisplay = document.getElementById('left-page');
            const rightPageDisplay = document.getElementById('right-page');
            const pageDataStorage = document.getElementById('page-data-storage');
            const coverContentDisplay = document.getElementById('cover-content-display');

            const prevButton = document.getElementById('prev-page');
            const nextButton = document.getElementById('next-page');
            const addImageButton = document.getElementById('add-image-button');
            const imageUploadInput = document.getElementById('image-upload-input');

            // Get all page content divs from storage and sort them
            const pages = Array.from(pageDataStorage.querySelectorAll('.page-content'))
                                   .sort((a, b) => parseInt(a.dataset.pageNumber) - parseInt(b.dataset.pageNumber));

            const totalPages = pages.length; // Total number of individual page sides
            // Calculate the number of viewable states (Cover, Spread 1, Spread 2...)
            const totalSpreads = Math.ceil(totalPages / 2) + 1;

            let currentSpreadIndex = 0; // 0 = Cover view, 1 = Pages 0 & 1, etc.
            let elementZIndex = 10; // Starting z-index for new elements

            // --- Drag and Drop Variables ---
            let draggedElement = null; // Element currently being dragged
            let offsetX, offsetY; // Mouse offset within the dragged element
            let dragStartX, dragStartY; // Initial mouse position for drag detection

            // --- Resize Variables ---
            let resizingElement = null; // Image element being resized
            let resizeHandle = null; // Specific handle being dragged
            let startX, startY, startWidth, startHeight; // Initial state for resize calculation
            let aspectRatio; // Aspect ratio of the image being resized

            // --- Selection Variable ---
            let selectedElement = null; // Currently selected scrapbook element

            const animationDuration = 600; // Page turn animation duration in milliseconds (matches CSS)

            // --- Function to update the visible pages ---
            function updateView() {
                deselectElement(); // Deselect any element when turning page

                // Clear existing content from display areas
                leftPageDisplay.innerHTML = '';
                rightPageDisplay.innerHTML = '';
                coverContentDisplay.style.display = 'none'; // Hide cover graphics by default

                let leftPageContent = null;
                let rightPageContent = null;

                // Determine content based on the current spread index
                if (currentSpreadIndex === 0) { // Cover view
                    leftPageContent = createPlaceholderPage("(Inside Cover)");
                    rightPageDisplay.appendChild(coverContentDisplay); // Show cover graphics
                    coverContentDisplay.style.display = 'flex';
                    addImageButton.disabled = true; // Disable add image on cover
                    addImageButton.title = "Cannot add images to the cover";
                } else { // Regular page spread view
                    const leftPageNumber = (currentSpreadIndex - 1) * 2;
                    const rightPageNumber = leftPageNumber + 1;

                    // Get page content from storage or create placeholders if out of bounds
                    leftPageContent = (leftPageNumber >= 0 && leftPageNumber < totalPages) ? pages[leftPageNumber] : createPlaceholderPage("(Blank)");
                    rightPageContent = (rightPageNumber >= 0 && rightPageNumber < totalPages) ? pages[rightPageNumber] : createPlaceholderPage("(End)");

                    // Enable add image button only if there's a real page visible
                    const leftIsReal = leftPageContent && !leftPageContent.classList.contains('placeholder-page');
                    const rightIsReal = rightPageContent && !rightPageContent.classList.contains('placeholder-page');
                    addImageButton.disabled = !(leftIsReal || rightIsReal);
                    addImageButton.title = addImageButton.disabled ? "No page available to add image" : "Add Image from Device";
                }

                // Add the determined content to the display areas and attach listeners
                if (leftPageContent) {
                    leftPageDisplay.appendChild(leftPageContent);
                    attachScrapbookListeners(leftPageContent);
                }
                if (rightPageContent && currentSpreadIndex !== 0) { // Don't add content to right if cover is showing
                    rightPageDisplay.appendChild(rightPageContent);
                    attachScrapbookListeners(rightPageContent);
                }

                updateButtonStates(); // Update navigation button states
            }

            // --- Helper to create placeholder page divs ---
            function createPlaceholderPage(text) {
                const placeholder = document.createElement('div');
                placeholder.classList.add('page-content', 'placeholder-page');
                placeholder.textContent = text;
                return placeholder;
            }

            // --- Selection Handling ---
            function selectElement(element) {
                // Deselect previous element if different
                if (selectedElement && selectedElement !== element) {
                    selectedElement.classList.remove('selected');
                    // Restore its z-index (remove selection boost)
                    selectedElement.style.zIndex = Math.max(10, parseInt(selectedElement.style.zIndex || 510) - 500);
                }
                // Select the new element
                if (element) {
                    element.classList.add('selected');
                    selectedElement = element;
                    // Bring selected element slightly forward (add selection boost)
                    element.style.zIndex = parseInt(element.style.zIndex || 10) + 500;
                }
            }

            function deselectElement() {
                if (selectedElement) {
                    selectedElement.classList.remove('selected');
                    // Restore its z-index (remove selection boost)
                     selectedElement.style.zIndex = Math.max(10, parseInt(selectedElement.style.zIndex || 510) - 500);
                    selectedElement = null;
                }
            }

            // Add global click listener to deselect elements when clicking outside
            document.addEventListener('click', (e) => {
                // Check if the click target is outside any scrapbook element or its controls
                if (!e.target.closest('.scrapbook-element')) {
                     // Check if the click is on the general background/page area
                     if (e.target.classList.contains('page-display') ||
                         e.target.classList.contains('page-content') ||
                         e.target.classList.contains('notebook') ||
                         e.target.classList.contains('notebook-container') ||
                         e.target.classList.contains('controls-container') || // Include controls container
                         e.target === document.body) {
                        deselectElement();
                    }
                }
                 // Specifically deselect if clicking the add image button itself
                 if (e.target === addImageButton || e.target.closest('#add-image-button')) {
                     // No need to deselect here if we want the button click to just work
                     // deselectElement();
                 }
            });


            // --- Scrapbook Functionality ---

            // Attaches necessary listeners to elements on a given page
            function attachScrapbookListeners(pageElement) {
                if (!pageElement || pageElement.classList.contains('placeholder-page')) return; // Skip placeholders

                // Update the global z-index counter based on existing elements on this page
                let maxZ = elementZIndex; // Start with current global max
                 pageElement.querySelectorAll('.scrapbook-element').forEach(el => {
                    const currentZ = parseInt(el.style.zIndex);
                     if (!isNaN(currentZ)) {
                         maxZ = Math.max(maxZ, currentZ);
                     }
                 });
                 elementZIndex = maxZ + 1; // Ensure new elements start above existing ones


                // Make existing elements interactive and ensure they have a z-index
                pageElement.querySelectorAll('.scrapbook-element').forEach(el => {
                    makeElementInteractive(el);
                    if (!el.style.zIndex) {
                        el.style.zIndex = elementZIndex++; // Assign z-index if missing
                    }
                });

                // Add listener to create text boxes on page click
                pageElement.addEventListener('click', handlePageClick);
                // Add listener for pasting content
                pageElement.addEventListener('paste', handlePaste);
            }

            // Handles clicks directly on the page content area to add text boxes
            function handlePageClick(e) {
                const contentArea = e.currentTarget;
                // Only proceed if clicking directly on the page background, not an existing element or placeholder
                if (e.target !== contentArea ||
                    contentArea.classList.contains('placeholder-page') ||
                    e.target.closest('.scrapbook-element')) {
                    return;
                }

                deselectElement(); // Deselect any other element

                // Create the text element
                const textElement = document.createElement('div');
                textElement.classList.add('scrapbook-element', 'scrapbook-text');
                textElement.setAttribute('contenteditable', 'true');
                textElement.textContent = 'Type here...'; // Placeholder text

                // Calculate position based on click coordinates relative to the page content area
                const rect = contentArea.getBoundingClientRect();
                const scrollX = contentArea.scrollLeft;
                const scrollY = contentArea.scrollTop;
                // Adjust slightly so the top-left corner isn't exactly under the cursor
                const x = e.pageX - rect.left + scrollX - 5;
                const y = e.pageY - rect.top + scrollY - 5;

                // Style and position the new element
                textElement.style.position = 'absolute';
                textElement.style.left = `${Math.max(0, x)}px`; // Ensure non-negative coordinates
                textElement.style.top = `${Math.max(0, y)}px`;
                elementZIndex++; // Increment global z-index
                textElement.style.zIndex = elementZIndex; // Assign new z-index

                // Add to page, make interactive, select, and focus
                contentArea.appendChild(textElement);
                makeElementInteractive(textElement);
                selectElement(textElement);
                textElement.focus();

                // Select the placeholder text for easy replacement by the user
                const selection = window.getSelection();
                const range = document.createRange();
                range.selectNodeContents(textElement);
                selection.removeAllRanges();
                selection.addRange(range);
            }

             // --- Function to add an image element (used by paste and upload) ---
            function addImageElement(imageDataUrl, targetPageElement) {
                if (!targetPageElement || targetPageElement.classList.contains('placeholder-page')) {
                    console.warn("Attempted to add image to invalid page.");
                    return; // Safety check
                }

                deselectElement(); // Deselect any currently selected element

                // Create container and image elements
                const imgElementContainer = document.createElement('div');
                imgElementContainer.classList.add('scrapbook-element', 'scrapbook-image');
                const img = document.createElement('img');
                img.src = imageDataUrl;
                // Apply initial size constraints
                img.style.maxWidth = '200px';
                img.style.maxHeight = '200px';
                imgElementContainer.appendChild(img);

                // Calculate initial position (near top-left of visible area)
                const pasteX = targetPageElement.scrollLeft + targetPageElement.offsetWidth * 0.1;
                const pasteY = targetPageElement.scrollTop + targetPageElement.offsetHeight * 0.1;

                imgElementContainer.style.position = 'absolute';
                imgElementContainer.style.left = `${pasteX}px`;
                imgElementContainer.style.top = `${pasteY}px`;
                elementZIndex++; // Increment and assign z-index
                imgElementContainer.style.zIndex = elementZIndex;

                // After the image loads, set the container size and add controls
                img.onload = () => {
                    // Use offsetWidth/Height which reflect the rendered size after max-width/height constraints
                    imgElementContainer.style.width = `${img.offsetWidth}px`;
                    imgElementContainer.style.height = `${img.offsetHeight}px`;
                    makeElementInteractive(imgElementContainer); // Add controls and listeners
                    selectElement(imgElementContainer); // Select the newly added image
                };
                // Handle image loading errors
                img.onerror = () => {
                    console.error("Failed to load image for scrapbook element.");
                    imgElementContainer.remove(); // Remove the broken element
                    alert("Failed to load the selected image.");
                };

                // Add the container to the target page
                targetPageElement.appendChild(imgElementContainer);
            }


            // Handles pasting content onto the page
            function handlePaste(e) {
                const contentArea = e.currentTarget;
                if (contentArea.classList.contains('placeholder-page')) return; // Don't paste onto placeholders

                e.preventDefault(); // Prevent default paste behavior
                const items = (e.clipboardData || window.clipboardData).items; // Get clipboard items

                // Iterate through clipboard items
                for (const item of items) {
                    if (item.type.indexOf('image') !== -1) { // Handle image pasting
                        const blob = item.getAsFile();
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            // Use the common function to add the image element
                            addImageElement(event.target.result, contentArea);
                        };
                        reader.readAsDataURL(blob); // Read image data as Data URL
                        break; // Handle only the first image found
                    } else if (item.type === 'text/plain') { // Handle text pasting
                         item.getAsString(text => {
                            deselectElement(); // Deselect before adding text
                            // Create the text element
                            const textElement = document.createElement('div');
                            textElement.classList.add('scrapbook-element', 'scrapbook-text');
                            textElement.setAttribute('contenteditable', 'true');
                            textElement.textContent = text;

                            // Calculate paste position (offset slightly from image paste position)
                            const rect = contentArea.getBoundingClientRect();
                            const scrollX = contentArea.scrollLeft;
                            const scrollY = contentArea.scrollTop;
                            const pasteX = scrollX + rect.width * 0.1 + 10;
                            const pasteY = scrollY + rect.height * 0.1 + 10;

                            // Style and position
                            textElement.style.position = 'absolute';
                            textElement.style.left = `${pasteX}px`;
                            textElement.style.top = `${pasteY}px`;
                            elementZIndex++;
                            textElement.style.zIndex = elementZIndex;

                            // Add to page, make interactive, select, and focus
                            contentArea.appendChild(textElement);
                            makeElementInteractive(textElement);
                            selectElement(textElement);
                            textElement.focus();
                        });
                        break; // Handle only the first text item found
                    }
                }
            }

            // Function to add delete button and resize handles to an element
            function addControls(element) {
                // Avoid adding controls multiple times
                 if (element.querySelector('.delete-button')) return;

                // --- Add Delete Button ---
                const deleteBtn = document.createElement('div');
                deleteBtn.classList.add('delete-button');
                deleteBtn.innerHTML = '&times;'; // 'X' symbol
                deleteBtn.title = 'Delete Element';
                // Add click listener to remove the element
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent triggering parent listeners (like selection)
                    element.remove(); // Remove the scrapbook element
                    if (selectedElement === element) selectedElement = null; // Clear selection if deleted
                });
                element.appendChild(deleteBtn);

                // --- Add Resize Handles (only for images) ---
                if (element.classList.contains('scrapbook-image')) {
                    ['nw', 'ne', 'sw', 'se'].forEach(handleType => {
                        const handle = document.createElement('div');
                        handle.classList.add('resize-handle', handleType);
                        // Add mousedown listener to initiate resizing
                        handle.addEventListener('mousedown', onResizeHandleMouseDown);
                        element.appendChild(handle);
                    });
                }
            }

            // Adds controls and makes an element draggable
            function makeElementInteractive(element) {
                addControls(element); // Ensure controls (delete/resize) are present

                // Add listener for dragging/selection initiation
                element.addEventListener('mousedown', onElementMouseDown);

                // Prevent default browser image dragging behavior
                const img = element.querySelector('img');
                if(img) {
                    img.ondragstart = () => false;
                }
            }

            // Mousedown handler for the scrapbook element itself (initiates drag/selection)
            function onElementMouseDown(e) {
                // Only respond to left mouse button
                if (e.button !== 0) return;
                // Ignore clicks on controls (they have their own handlers)
                if (e.target.classList.contains('resize-handle') || e.target.classList.contains('delete-button')) {
                    return;
                }

                const element = e.currentTarget; // The scrapbook-element div
                selectElement(element); // Select the clicked element

                // --- Prepare for potential drag ---
                draggedElement = element; // Set the element being potentially dragged
                const rect = draggedElement.getBoundingClientRect(); // Get element dimensions/position
                // Calculate mouse offset within the element
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                // Record starting mouse position to detect drag vs. click
                dragStartX = e.clientX;
                dragStartY = e.clientY;

                // Add listeners to the document to track mouse movement and release
                document.addEventListener('mousemove', onDragMouseMove);
                document.addEventListener('mouseup', onDragMouseUp);

                // Prevent default text selection *if* not clicking inside an already focused contenteditable
                 if (!element.contains(document.activeElement) || !element.hasAttribute('contenteditable')) {
                    // e.preventDefault(); // Be cautious: might interfere with focusing text boxes on click
                 }
            }


            // Handles mouse movement during a potential drag operation
            function onDragMouseMove(e) {
                if (!draggedElement) return; // Exit if no element is being dragged

                // Check if the mouse has moved enough to be considered a drag
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;
                if (!draggedElement.classList.contains('dragging') && Math.sqrt(dx*dx + dy*dy) > 5) { // Drag threshold: 5 pixels
                     draggedElement.classList.add('dragging'); // Add dragging class
                     draggedElement.style.zIndex = 9999; // Bring fully to front when dragging
                }

                // If dragging is active, update the element's position
                if (draggedElement.classList.contains('dragging')) {
                    e.preventDefault(); // Prevent text selection during drag

                    const parent = draggedElement.parentElement; // The page-content area
                    const parentRect = parent.getBoundingClientRect(); // Parent dimensions/position

                    // Calculate new top/left based on mouse position, offset, and parent scroll
                    let x = e.clientX - parentRect.left - offsetX + parent.scrollLeft;
                    let y = e.clientY - parentRect.top - offsetY + parent.scrollTop;

                    // Constrain the element within the parent boundaries
                    x = Math.max(0, Math.min(x, parent.scrollWidth - draggedElement.offsetWidth));
                    y = Math.max(0, Math.min(y, parent.scrollHeight - draggedElement.offsetHeight));

                    // Apply the new position
                    draggedElement.style.left = `${x}px`;
                    draggedElement.style.top = `${y}px`;
                }
            }

            // Handles mouse button release after a mousedown on an element
            function onDragMouseUp(e) {
                if (!draggedElement) return; // Exit if no element was being tracked

                const wasDragging = draggedElement.classList.contains('dragging'); // Check if a drag occurred
                draggedElement.classList.remove('dragging'); // Remove dragging class

                if (wasDragging) {
                    // If it was a drag, assign the next highest z-index permanently
                    elementZIndex++;
                    draggedElement.style.zIndex = elementZIndex;
                } else {
                    // If it was just a click (no significant movement), the element is already selected.
                    // selectElement() handled the temporary z-index boost for selection.
                    // No z-index change needed here, it will reset on deselect.
                }

                // Clean up: remove document listeners and reset dragged element variable
                draggedElement = null;
                document.removeEventListener('mousemove', onDragMouseMove);
                document.removeEventListener('mouseup', onDragMouseUp);
            }


            // --- Resize Functionality ---

            // Mousedown handler for resize handles
            function onResizeHandleMouseDown(e) {
                e.stopPropagation(); // Prevent element drag/selection
                e.preventDefault(); // Prevent text selection

                resizingElement = e.target.closest('.scrapbook-image'); // Get the parent image element
                if (!resizingElement) return; // Should always find one, but safety check

                resizeHandle = e.target; // Store the specific handle being dragged
                const img = resizingElement.querySelector('img'); // Get the actual image inside

                // Record initial state for calculations
                startX = e.clientX;
                startY = e.clientY;
                startWidth = resizingElement.offsetWidth;
                startHeight = resizingElement.offsetHeight;
                // Calculate aspect ratio (use natural dimensions for accuracy)
                aspectRatio = img ? img.naturalWidth / img.naturalHeight : startWidth / startHeight;
                if (isNaN(aspectRatio) || aspectRatio <= 0) aspectRatio = 1; // Fallback to 1:1 if calculation fails


                // Add listeners to track resize movement and release
                document.addEventListener('mousemove', onResizeMouseMove);
                document.addEventListener('mouseup', onResizeMouseUp);
            }

            // Handles mouse movement during a resize operation
            function onResizeMouseMove(e) {
                if (!resizingElement || !resizeHandle) return; // Exit if not resizing
                e.preventDefault(); // Prevent text selection

                // Calculate mouse movement delta
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                // Store initial position for adjustments later
                 const originalLeft = parseFloat(resizingElement.style.left || 0);
                 const originalTop = parseFloat(resizingElement.style.top || 0);

                let newWidth = startWidth;
                let newHeight = startHeight;

                // Calculate new dimensions based on the handle being dragged, maintaining aspect ratio
                // Corner handles prioritize width change based on horizontal mouse movement (dx)
                if (resizeHandle.classList.contains('se')) {
                    newWidth = startWidth + dx;
                    newHeight = newWidth / aspectRatio;
                } else if (resizeHandle.classList.contains('sw')) {
                    newWidth = startWidth - dx;
                    newHeight = newWidth / aspectRatio;
                    // Left position needs adjustment
                } else if (resizeHandle.classList.contains('ne')) {
                    newWidth = startWidth + dx;
                    newHeight = newWidth / aspectRatio;
                    // Top position needs adjustment
                } else if (resizeHandle.classList.contains('nw')) {
                    newWidth = startWidth - dx;
                    newHeight = newWidth / aspectRatio;
                    // Left and Top positions need adjustment
                }
                // (Add logic here for N, S, E, W handles if implementing non-aspect-ratio resize)


                 // Enforce minimum size
                 const minSize = 30; // Minimum pixels width/height
                 newWidth = Math.max(minSize, newWidth);
                 // Recalculate the other dimension based on aspect ratio after applying minWidth
                 newHeight = newWidth / aspectRatio;
                 // Now ensure minHeight is also met, potentially overriding the width-based calculation
                 if (newHeight < minSize) {
                    newHeight = minSize;
                    newWidth = newHeight * aspectRatio; // Recalculate width based on minHeight
                 }

                // Apply the new dimensions
                resizingElement.style.width = `${newWidth}px`;
                resizingElement.style.height = `${newHeight}px`;

                 // Adjust position for handles that affect top/left based on the *final* size change
                 const widthChange = startWidth - newWidth;
                 const heightChange = startHeight - newHeight;

                 if (resizeHandle.classList.contains('sw') || resizeHandle.classList.contains('nw')) {
                     resizingElement.style.left = `${originalLeft + widthChange}px`;
                 }
                 if (resizeHandle.classList.contains('ne') || resizeHandle.classList.contains('nw')) {
                      resizingElement.style.top = `${originalTop + heightChange}px`;
                 }
            }

            // Handles mouse button release after a resize operation
            function onResizeMouseUp(e) {
                if (!resizingElement) return; // Exit if not resizing

                // Clean up: remove listeners and reset variables
                resizingElement = null;
                resizeHandle = null;
                document.removeEventListener('mousemove', onResizeMouseMove);
                document.removeEventListener('mouseup', onResizeMouseUp);
            }


            // --- Navigation ---
            function nextPage() {
                if (!nextButton.disabled) { // Check if button is enabled
                    performPageTurn(1); // Turn forward
                }
            }

            function prevPage() {
                 if (!prevButton.disabled) { // Check if button is enabled
                    performPageTurn(-1); // Turn backward
                 }
            }

            // Handles the page turning animation and logic
            function performPageTurn(direction) {
                 deselectElement(); // Deselect elements before turning

                 // Determine animation classes based on turn direction
                 const outLeftClass = direction > 0 ? 'page-flipping-out-left' : 'page-flipping-in-left';
                 const outRightClass = direction > 0 ? 'page-flipping-out-right' : 'page-flipping-in-right';
                 const inLeftClass = direction > 0 ? 'page-flipping-in-left' : 'page-flipping-out-left';
                 const inRightClass = direction > 0 ? 'page-flipping-in-right' : 'page-flipping-out-right';

                 // Apply 'out' animation classes to current pages
                 leftPageDisplay.classList.add(outLeftClass);
                 rightPageDisplay.classList.add(outRightClass);

                 // Disable control buttons during animation
                 prevButton.disabled = true;
                 nextButton.disabled = true;
                 addImageButton.disabled = true;

                 // After the 'out' animation finishes:
                 setTimeout(() => {
                     moveVisibleContentToStorage(); // Move old content back to hidden storage
                     currentSpreadIndex += direction; // Update the current view index
                     updateView(); // Load the new page content (this also updates addImageButton state)

                     // Apply 'in' animation classes to the new content containers
                     // Note: updateView already added the content, we just add classes to the containers
                     leftPageDisplay.classList.add(inLeftClass);
                     rightPageDisplay.classList.add(inRightClass);

                     // Force reflow/repaint to ensure the browser registers the 'in' start state
                     void leftPageDisplay.offsetWidth;

                     // Remove the 'in' classes to trigger the transition to the final (visible) state
                     leftPageDisplay.classList.remove(inLeftClass);
                     rightPageDisplay.classList.remove(inRightClass);

                     // Clean up 'out' classes (can be done slightly earlier or now)
                     leftPageDisplay.classList.remove(outLeftClass);
                     rightPageDisplay.classList.remove(outRightClass);


                     // After the 'in' animation finishes, re-enable navigation buttons
                     setTimeout(() => {
                         updateButtonStates(); // Update nav button states based on the new index
                     }, animationDuration);

                 }, animationDuration); // Wait for the 'out' animation duration
            }


            // Moves currently visible page content back to the hidden storage div
            function moveVisibleContentToStorage() {
                // Move left page content if it's real content
                const leftContent = leftPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                if (leftContent) {
                    // Detach listeners? Not strictly needed if re-attached in updateView/attachScrapbookListeners
                    pageDataStorage.appendChild(leftContent);
                }
                // Move right page content if it's real content
                const rightContent = rightPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                 if (rightContent) {
                    pageDataStorage.appendChild(rightContent);
                }
            }

            // Updates the enabled/disabled state of navigation and add image buttons
            function updateButtonStates() {
                 // --- Update Nav Buttons ---
                prevButton.disabled = currentSpreadIndex <= 0; // Disable prev on cover/first spread

                const lastPageNumber = totalPages - 1;
                // Calculate the page numbers currently (or about to be) displayed
                const leftVisiblePageNum = (currentSpreadIndex - 1) * 2;
                const rightVisiblePageNum = leftVisiblePageNum + 1;

                // Disable next if the right page shown *is* the last page OR
                // if the left page shown *is* the last page (for odd total pages)
                nextButton.disabled = rightVisiblePageNum >= lastPageNumber;

                // --- Update Add Image Button --- (Based on whether real pages are visible)
                 const leftPage = leftPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                 const rightPage = rightPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                 // Disable if on cover OR if both visible pages are placeholders
                 addImageButton.disabled = currentSpreadIndex === 0 || (!leftPage && !rightPage);
                 // Update tooltip based on disabled state
                 addImageButton.title = addImageButton.disabled ? (currentSpreadIndex === 0 ? "Cannot add images to the cover" : "No page available to add image") : "Add Image from Device";
            }

            // --- Event Listeners for Buttons ---
            prevButton.addEventListener('click', prevPage);
            nextButton.addEventListener('click', nextPage);

            // --- Image Upload Button Listener ---
            addImageButton.addEventListener('click', () => {
                if (!addImageButton.disabled) { // Only trigger if not disabled
                    imageUploadInput.click(); // Trigger the hidden file input dialog
                }
            });

            // --- File Input Change Listener ---
            imageUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0]; // Get the selected file
                if (file && file.type.startsWith('image/')) { // Check if it's an image
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        // Determine the target page (prefer right, then left, ensure it's not a placeholder)
                        let targetPage = rightPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                        if (!targetPage) {
                            targetPage = leftPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                        }

                        if (targetPage) {
                            addImageElement(event.target.result, targetPage); // Add the image
                        } else {
                            // This case should be prevented by the disabled state, but alert as fallback
                            alert("Cannot add image here. Please navigate to a valid page.");
                        }
                    };
                    reader.readAsDataURL(file); // Read the file as Data URL
                } else if (file) {
                    alert("Please select a valid image file (e.g., JPG, PNG, GIF)."); // Inform user of invalid file type
                }
                // Reset the input value so the 'change' event fires even if the same file is selected again
                e.target.value = null;
            });


            // --- Keyboard Navigation & Actions ---
            document.addEventListener('keydown', (e) => {
                // Ignore keyboard input if focus is inside an editable element or input field
                if (e.target.closest('[contenteditable="true"]') || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    // Special case: Allow Backspace/Delete to remove the selected element if focus is *not* inside it
                    if ((e.key === 'Backspace' || e.key === 'Delete') && selectedElement) {
                         // Check if the active element is the selected element itself or something outside it
                         if (document.activeElement !== selectedElement && !selectedElement.contains(document.activeElement)) {
                             e.preventDefault(); // Prevent default (e.g., browser back)
                             selectedElement.remove();
                             selectedElement = null; // Clear selection
                         }
                         // Otherwise, allow default text deletion behavior within the editable area
                         return;
                    }
                    // Allow normal arrow key navigation within editable areas
                    if (e.key.startsWith('Arrow')) {
                        return;
                    }
                    // Allow other keys for typing
                    return;
                 }

                // Handle page turns with arrow keys if buttons are enabled
                if (e.key === 'ArrowLeft' && !prevButton.disabled) {
                    e.preventDefault(); // Prevent scrolling
                    prevPage();
                } else if (e.key === 'ArrowRight' && !nextButton.disabled) {
                    e.preventDefault(); // Prevent scrolling
                    nextPage();
                // Handle element deletion with Backspace/Delete if an element is selected
                } else if ((e.key === 'Backspace' || e.key === 'Delete') && selectedElement) {
                     e.preventDefault(); // Prevent browser back navigation etc.
                     selectedElement.remove();
                     selectedElement = null; // Clear selection
                 }
            });

            // --- Initial Setup ---
            updateView(); // Load the initial view (cover)

        }); // End DOMContentLoaded
    </script>

</body>
</html>
